package plencdesc

import (
	"fmt"
	"unsafe"

	"github.com/philpearl/plenc"
	"github.com/philpearl/plenc/plenccore"
)

//go:generate stringer -type FieldType
type FieldType int

const (
	FieldTypeInt FieldType = iota
	FieldTypeUint
	FieldTypeFloat32
	FieldTypeFloat64
	FieldTypeString
	FieldTypeSlice
	FieldTypeStruct
)

type Descriptor struct {
	// Index is the plenc index of this field
	Index int `plenc:"1"`
	// Name is the name of the field
	Name string `plenc:"2"`
	// Type is the type of the field
	Type FieldType `plenc:"3"`
	// WireType is the expected plenc wire type of this field
	WireType plenccore.WireType `plenc:"4"`
	// Elements is valid for FieldTypeSlice & FieldTypeStruct. For
	// FieldTypeSlice we expect one entry that describes the elements of the
	// slice. For FieldTypeStruct we expect an entry for each field in the
	// struct
	Elements []Descriptor `plenc:"5"`
}

func (d *Descriptor) Read(data []byte) (output interface{}, err error) {
	output, _, err = d.read(data)

	return output, err
}

func (d *Descriptor) read(data []byte) (output interface{}, n int, err error) {
	switch d.Type {
	case FieldTypeInt:
		var v int64
		n, err = plenc.IntCodec[int64]{}.Read(data, unsafe.Pointer(&v), plenccore.WTVarInt)
		return v, n, err

	case FieldTypeUint:
		var v uint64
		n, err = plenc.UintCodec[uint64]{}.Read(data, unsafe.Pointer(&v), plenccore.WTVarInt)
		return v, n, err

	case FieldTypeFloat32:
		var v float32
		n, err = plenc.Float32Codec{}.Read(data, unsafe.Pointer(&v), plenccore.WT32)
		return v, n, err

	case FieldTypeFloat64:
		var v float64
		n, err = plenc.Float64Codec{}.Read(data, unsafe.Pointer(&v), plenccore.WT64)
		return v, n, err

	case FieldTypeString:
		var v string
		n, err = plenc.StringCodec{}.Read(data, unsafe.Pointer(&v), plenccore.WTLength)
		return v, n, err

	case FieldTypeSlice:
		return d.readAsSlice(data)

	case FieldTypeStruct:
		return d.readAsStruct(data)
	}

	return nil, 0, fmt.Errorf("unrecognised field type %s", d.Type)
}

func (d *Descriptor) readAsSlice(data []byte) (output interface{}, n int, err error) {
	var slice []interface{}
	elt := &d.Elements[0]
	switch elt.Type {
	case FieldTypeFloat32, FieldTypeFloat64, FieldTypeInt, FieldTypeUint:
		// If data is generated by protobuf this could be an element of a slice.
		// We won't support that for now. So this is either a float64 or float32
		offset := 0
		for offset < len(data) {
			v, n, err := elt.read(data[offset:])
			if err != nil {
				return nil, 0, err
			}
			offset += n
			slice = append(slice, v)
		}
		return slice, offset, nil

	case FieldTypeStruct, FieldTypeSlice, FieldTypeString:
		count, n := plenccore.ReadVarUint(data)
		if n < 0 {
			return nil, 0, fmt.Errorf("corrupt data looking for WTSlice count")
		}
		slice = make([]interface{}, 0, count)

		offset := n
		for i := 0; i < int(count); i++ {
			s, n := plenccore.ReadVarUint(data[offset:])
			if n <= 0 {
				return nil, 0, fmt.Errorf("invalid varint for slice entry %d", i)
			}
			offset += n
			if s == 0 {
				continue
			}

			v, n, err := elt.read(data[offset : offset+int(s)])
			if err != nil {
				return nil, 0, err
			}
			slice = append(slice, v)
			offset += n
		}

		return slice, offset, nil

	default:
		return nil, 0, fmt.Errorf("slice of unexpected element types %s", elt.Type)
	}
}

func (d *Descriptor) readAsStruct(data []byte) (output interface{}, n int, err error) {
	l := len(data)
	outputM := make(map[string]interface{})

	var offset int
	for offset < l {
		wt, index, n := plenccore.ReadTag(data[offset:])
		offset += n

		var elt *Descriptor
		for i := range d.Elements {
			candidate := &d.Elements[i]
			if candidate.Index == index {
				elt = candidate
				break
			}
		}

		if elt == nil {
			// Field corresponding to index does not exist
			n, err := plenccore.Skip(data[offset:], wt)
			if err != nil {
				return nil, 0, fmt.Errorf("failed to skip field %d in %s: %w", index, d.Name, err)
			}
			offset += n
			continue
		}

		fl := l
		if wt == plenccore.WTLength {
			// For WTLength types we read out the length and ensure the data we
			// read the field from is the right length
			v, n := plenccore.ReadVarUint(data[offset:])
			if n <= 0 {
				return nil, 0, fmt.Errorf("varuint overflow reading field %d of %s", index, d.Name)
			}
			offset += n
			fl = int(v) + offset
			if fl > l {
				return nil, 0, fmt.Errorf("length %d of field %d of %s exceeds data length", fl, index, d.Name)
			}
		}

		v, n, err := elt.read(data[offset:fl])
		if err != nil {
			return nil, 0, fmt.Errorf("failed reading field %d(%s) of %s. %w", index, elt.Name, d.Name, err)
		}
		outputM[elt.Name] = v
		offset += n
	}

	return outputM, offset, nil
}
